<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Soil Sampling Prototype</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #map { height: 100%; }
    .panel {
      position: absolute; top: 10px; right: 10px; z-index: 9999;
      width: 320px;
      background: white; padding: 12px; border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font: 13px/1.4 Arial, sans-serif;
    }
    .row { margin: 8px 0; }
    label { display:block; font-weight:600; margin-bottom:4px; }
    input, select, button { width: 100%; padding: 6px; box-sizing: border-box; }
    button { cursor: pointer; }
    .small { font-size: 12px; color: #444; }
    .pill { display:inline-block; padding:2px 6px; border-radius: 999px; background:#eee; margin-right:6px; }
    .status { margin-top: 8px; padding: 6px; background:#f6f6f6; border-radius: 6px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  </style>
</head>
<body>
<div id="map"></div>

<div class="panel">
  <div class="row"><strong>Soil Sampling Planner</strong></div>

  <div class="row small">
    1) Draw a polygon on the map.<br>
    2) Click <span class="pill">Analyze polygon</span> to get recommended sample sizes.<br>
    3) Choose mode + click <span class="pill">Generate samples</span>.
  </div>

  <div class="row">
    <label>Mode</label>
    <select id="mode">
      <option value="manual">Manual (choose N)</option>
      <option value="budget">Budget ($ → N)</option>
      <option value="tier">Recommended Tier</option>
    </select>
  </div>

  <div class="row grid">
    <div>
      <label>Manual N</label>
      <input id="manualN" type="number" value="30" min="1" step="1">
    </div>
    <div>
      <label>Cost / sample ($)</label>
      <input id="costPerSample" type="number" value="25" min="1" step="1">
    </div>
  </div>

  <div class="row">
    <label>Budget ($)</label>
    <input id="budget" type="number" value="750" min="0" step="25">
  </div>

  <div class="row">
    <label>Tier</label>
    <select id="tier">
      <option value="weak">Weak</option>
      <option value="medium">Medium</option>
      <option value="good" selected>Good</option>
      <option value="perfect">Perfect</option>
    </select>
  </div>

  <div class="row">
    <label>Replicates (optional)</label>
    <select id="repToggle">
      <option value="off" selected>Off</option>
      <option value="on">On</option>
    </select>
  </div>

  <div class="row grid">
    <div>
      <label>Replicate % (0–50)</label>
      <input id="repFrac" type="number" value="10" min="0" max="50" step="1">
    </div>
    <div>
      <label>Radius (m)</label>
      <input id="repRadius" type="number" value="3" min="0" step="1">
    </div>
  </div>

  <div class="row grid">
    <button id="analyzeBtn">Analyze polygon</button>
    <button id="sampleBtn">Generate samples</button>
  </div>

  <div class="row small" id="recoBox">
    Candidates: —<br>
    Suggested N (weak/med/good/perfect): —<br>
  </div>

  <div class="status" id="status">Ready</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
  const statusEl = document.getElementById('status');
  const setStatus = (m) => statusEl.textContent = m;

  const map = L.map('map').setView([40.45, -86.99], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

  // Auto-zoom to dataset extent
  fetch('/api/extent')
    .then(r => r.ok ? r.json() : null)
    .then(d => { if (d?.bounds) map.fitBounds(d.bounds, { padding: [20,20] }); })
    .catch(() => { /* ignore */ });

  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  const drawControl = new L.Control.Draw({
    edit: { featureGroup: drawnItems },
    draw: { polygon: true, polyline: false, rectangle: false, circle: false, marker: false, circlemarker: false }
  });
  map.addControl(drawControl);

  let sampleLayer = null;
  let currentPolygon = null;
  let lastReco = null;

  async function postJSON(url, payload) {
    const r = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!r.ok) {
      const txt = await r.text();
      throw new Error(`HTTP ${r.status}: ${txt}`);
    }
    return await r.json();
  }

  function updateRecoBox(reco) {
    const box = document.getElementById('recoBox');
    if (!reco) {
      box.innerHTML = `Candidates: —<br>Suggested N (weak/med/good/perfect): —<br>`;
      return;
    }
    box.innerHTML =
      `Candidates: <b>${reco.candidates_count}</b><br>` +
      `Suggested N: ` +
      `weak=<b>${reco.tiers.weak}</b>, ` +
      `medium=<b>${reco.tiers.medium}</b>, ` +
      `good=<b>${reco.tiers.good}</b>, ` +
      `perfect=<b>${reco.tiers.perfect}</b><br>`;
  }

  function computeNFromMode() {
    const mode = document.getElementById('mode').value;
    const cost = parseFloat(document.getElementById('costPerSample').value || "25");
    const manualN = parseInt(document.getElementById('manualN').value || "1", 10);
    const budget = parseFloat(document.getElementById('budget').value || "0");
    const tier = document.getElementById('tier').value;

    if (mode === 'manual') return manualN;

    if (mode === 'budget') {
      const n = Math.floor(budget / Math.max(1, cost));
      return Math.max(1, n);
    }

    // tier mode
    if (lastReco && lastReco.tiers && lastReco.tiers[tier] != null) {
      return parseInt(lastReco.tiers[tier], 10);
    }
    // fallback
    return manualN;
  }

  async function analyzePolygon() {
    if (!currentPolygon) {
      alert("Draw a polygon first.");
      return;
    }
    const cost = parseFloat(document.getElementById('costPerSample').value || "25");
    setStatus("Analyzing polygon (recommendations)...");
    try {
      const reco = await postJSON('/api/recommend-n', { polygon: currentPolygon, cost_per_sample: cost });
      lastReco = reco;
      updateRecoBox(reco);

      // auto-set manual N to "good" if available
      if (reco?.tiers?.good) {
        document.getElementById('manualN').value = reco.tiers.good;
        document.getElementById('tier').value = 'good';
      }

      setStatus("Recommendations updated.");
    } catch (err) {
      console.error(err);
      setStatus("Analyze failed");
      alert("Analyze failed:\n" + err.message);
    }
  }

  async function generateSamples() {
    if (!currentPolygon) {
      alert("Draw a polygon first.");
      return;
    }

    const n = computeNFromMode();

    const repOn = document.getElementById('repToggle').value === 'on';
    const repFrac = repOn ? (parseFloat(document.getElementById('repFrac').value || "0") / 100.0) : 0.0;
    const repRadius = repOn ? parseFloat(document.getElementById('repRadius').value || "0") : 0.0;

    setStatus(`Selecting samples (N=${n})...`);

    try {
      const data = await postJSON('/api/suggest-samples', {
        polygon: currentPolygon,
        n_samples: n,
        replicate_fraction: repFrac,
        replicate_radius_m: repRadius
      });

      if (sampleLayer) map.removeLayer(sampleLayer);

      const nout = (data.features || []).length;
      setStatus(`Done: ${nout} points`);

      sampleLayer = L.geoJSON(data, {
        pointToLayer: (feature, latlng) => {
          const isRep = !!feature.properties?.is_replicate;
          const radius = isRep ? 4 : 6;
          const weight = isRep ? 2 : 3;
          return L.circleMarker(latlng, { radius, weight })
            .bindPopup(
              `ID: ${feature.properties?.id ?? "NA"}<br>` +
              `Replicate: ${isRep ? "Yes" : "No"}<br>` +
              (isRep ? `Replicate of: ${feature.properties?.replicate_of}` : "")
            );
        }
      }).addTo(map);

    } catch (err) {
      console.error(err);
      setStatus("Fetch failed");
      alert("Error fetching samples:\n" + err.message);
    }
  }

  document.getElementById('analyzeBtn').addEventListener('click', analyzePolygon);
  document.getElementById('sampleBtn').addEventListener('click', generateSamples);

  map.on(L.Draw.Event.CREATED, function (event) {
    drawnItems.clearLayers();
    drawnItems.addLayer(event.layer);

    currentPolygon = event.layer.toGeoJSON().geometry;
    lastReco = null;
    updateRecoBox(null);
    setStatus("Polygon set. Click 'Analyze polygon'.");
  });
</script>
</body>
</html>

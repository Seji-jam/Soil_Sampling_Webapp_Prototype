<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Soil Sampling Prototype</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #map { height: 100%; }

    /* RIGHT panel */
    .panel {
      position: absolute;
      z-index: 9999;
      background: white;
      padding: 12px;
      border-radius: 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.22);
      font: 13px/1.4 Arial, sans-serif;
      max-height: calc(100% - 20px);
      overflow: auto;
      width: 360px;
      top: 10px;
      right: 10px;
    }

    .row { margin: 8px 0; }
    label { display:block; font-weight:600; margin-bottom:4px; }
    input, select, button, textarea { width: 100%; padding: 6px; box-sizing: border-box; }
    textarea {
      min-height: 70px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
    }
    button { cursor: pointer; }
    .small { font-size: 12px; color: #444; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .hidden { display: none; }

    /* Smaller circular vertex handles */
    .leaflet-div-icon.leaflet-editing-icon {
      width: 10px !important;
      height: 10px !important;
      margin-left: -5px !important;
      margin-top: -5px !important;
      border-radius: 50% !important;
      background: #ffffff !important;
      border: 2px solid #3388ff !important;
      box-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }

    /* Floating show button (right panel) */
    .floating-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10000;
      background: white;
      border-radius: 10px;
      padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.22);
      display: none;
    }

    /* ===== Leaflet "merged" polygon control ===== */
    .leaflet-control.polygon-control {
      width: 270px;
      padding: 10px;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.20);
      border: 1px solid rgba(0,0,0,0.10);

      background: rgba(255,255,255,0.78);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);

      font: 13px/1.3 Arial, sans-serif;
    }
    .poly-head {
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:8px;
      font-weight:700;
    }
    .poly-head button {
      width:auto;
      padding: 4px 8px;
      font-weight:600;
    }
    .poly-body.hidden { display:none; }
    .poly-mini {
      font-size:12px;
      color:#444;
      margin-bottom:6px;
    }
    .poly-body textarea { min-height: 64px; }

    hr.sep {
      border: none;
      border-top: 1px solid #eee;
      margin: 10px 0;
    }

    /* Keep the basemap toggle visible even with the right panel */
    .leaflet-control-layers {
      box-shadow: 0 2px 10px rgba(0,0,0,0.18);
      border-radius: 10px;
    }
  </style>
</head>
<body>
<div id="map"></div>

<!-- RIGHT: sampling + outputs -->
<div class="panel" id="rightPanel">
  <div class="row" style="display:flex; justify-content:space-between; align-items:center;">
    <strong>Sampling Planner</strong>
    <button id="hideRightBtn" style="width:auto; padding:6px 10px;">Hide</button>
  </div>

  <!-- Suggestions (polygon-only; shown at top) -->
  <div class="row">
    <label>Polygon suggestions</label>
    <div class="grid" style="grid-template-columns: 1fr 1fr;">
      <select id="metric" title="Metric used for representativeness">
        <option value="bd" selected>BD (Gaussian)</option>
        <option value="kld">KLD (Gaussian)</option>
      </select>
      <button id="analyzeBtn" disabled>Analyze polygon</button>
    </div>
    <div class="small" id="analyzeHint">Draw / set a polygon to enable analysis.</div>
    <div class="small" id="aoiHint">Tip: you can also upload an AOI as <b>KML/KMZ</b>, <b>GeoJSON</b>, or a zipped <b>Shapefile</b> in the <b>Polygon</b> control on the map (top-left) → <i>Polygon input</i> → <i>Upload file</i>.</div>
    <div class="small" style="margin-top:6px;">
      Tip: you can also upload AOI files (KML/KMZ/GeoJSON/ZIP Shapefile) using the <b>Polygon</b> box on the map (top-left).
    </div>
  </div>

  <div class="row small" id="recoBox">
    Area: —<br>
    Candidates: —<br>
    Recommendations: —<br>
  </div>

  <hr class="sep">

  <!-- Sampling selection mode -->
  <div class="row">
    <label>Mode</label>
    <select id="mode">
      <option value="manual">Manual (choose N)</option>
      <option value="budget">Budget ($ → N)</option>
      <option value="tier">Recommended Tier</option>
    </select>
  </div>

  <div class="row grid">
    <div>
      <label>Manual N</label>
      <input id="manualN" type="number" value="30" min="1" step="1">
    </div>
    <div>
      <label>Cost / sample ($)</label>
      <input id="costPerSample" type="number" value="25" min="1" step="1">
    </div>
  </div>

  <div class="row">
    <label>Budget ($)</label>
    <input id="budget" type="number" value="750" min="0" step="25">
  </div>

  <div class="row">
    <label>Tier</label>
    <select id="tier">
      <option value="weak">Weak</option>
      <option value="medium">Medium</option>
      <option value="good" selected>Good</option>
      <option value="perfect">Perfect</option>
    </select>
  </div>

  <div class="row">
    <button id="sampleBtn" disabled>Generate samples</button>
  </div>

  <div class="row">
    <label>Selected sample coordinates</label>
    <textarea id="samplesBox" readonly placeholder="Generate samples to see coordinates..."></textarea>
    <div class="grid" style="grid-template-columns: 1fr 1fr 1fr;">
      <button id="copyBtn">Copy</button>
      <select id="downloadFormat" title="Download format">
        <option value="csv" selected>CSV</option>
        <option value="geojson">GeoJSON</option>
        <option value="kml">KML</option>
        <option value="kmz">KMZ</option>
        <option value="shp">Shapefile (ZIP)</option>
      </select>
      <button id="downloadBtn">Download</button>
    </div>
    <div class="small" style="margin-top:6px;">
      GeoJSON works well for QGIS/ArcGIS and web tools. KML/KMZ is convenient for Google Earth. Shapefile ZIP is common in older GIS workflows.
    </div>
  </div>
</div>

<div class="floating-btn" id="showRightFloat">
  <button id="showRightBtn" style="width:auto; padding:6px 10px;">Show planner</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<!-- Turf.js for accurate polygon area (geodesic) -->
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<!-- JSZip for KMZ handling (read/write) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- Shapefile (ZIP) -> GeoJSON -->
<script src="https://unpkg.com/shpjs@6.2.0/dist/shp.min.js"></script>
<!-- KML -> GeoJSON -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
<!-- GeoJSON -> KML -->
<script src="https://unpkg.com/tokml@0.4.0/tokml.js"></script>
<!-- GeoJSON -> Shapefile (ZIP) -->
<script src="https://cdn.jsdelivr.net/npm/shp-write@0.3.2/shpwrite.js"></script>
<script>
  const map = L.map('map').setView([40.45, -86.99], 12);

  // Basemaps
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  });
  const esriImagery = L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { maxZoom: 19, attribution: 'Tiles &copy; Esri' }
  );
  osm.addTo(map);

  // Put basemap toggle at bottom-left so it does not hide behind the right panel.
  L.control.layers(
    { 'OpenStreetMap': osm, 'Satellite (Esri)': esriImagery },
    {},
    { position: 'bottomleft', collapsed: false }
  ).addTo(map);

  fetch('/api/extent')
    .then(r => r.ok ? r.json() : null)
    .then(d => { if (d && d.bounds) map.fitBounds(d.bounds, { padding: [20,20] }); })
    .catch(() => {});

  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  const drawControl = new L.Control.Draw({
    position: 'topleft',
    edit: { featureGroup: drawnItems },
    draw: { polygon: true, polyline: false, rectangle: false, circle: false, marker: false, circlemarker: false }
  });
  map.addControl(drawControl);

  // ===== merged polygon control (sits near draw toolbar) =====
  const PolygonControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
      const container = L.DomUtil.create('div', 'leaflet-control polygon-control');
      container.innerHTML = `
        <div class="poly-head">
          <div>Polygon</div>
          <button id="polyToggleBtn" type="button">Hide</button>
        </div>

        <div class="poly-body" id="polyBody">
          <div class="poly-mini">
            Draw a polygon, paste coordinates, or upload an AOI file.
          </div>

          <div class="row">
            <label>Polygon input</label>
            <select id="polyMode">
              <option value="draw" selected>Draw on map</option>
              <option value="coords">Paste coordinates</option>
              <option value="file">Upload file (KML/KMZ/GeoJSON/ZIP Shapefile)</option>
            </select>
          </div>

          <div class="row" id="fileBox" style="display:none;">
            <label>Upload AOI file</label>
            <div class="small">Accepted: .geojson/.json, .kml, .kmz, or zipped shapefile (.zip containing .shp/.shx/.dbf).</div>
            <input id="polyFileInput" type="file" accept=".geojson,.json,.kml,.kmz,.zip" />
            <div class="small" id="polyFileStatus" style="margin-top:6px;">No file selected.</div>
          </div>

          <div class="row" id="coordsBox" style="display:none;">
            <label>Paste polygon coordinates</label>
            <div class="small">One point per line. lat,lon or lon,lat.</div>
            <textarea id="coordsInput" placeholder="40.4501, -86.9902\n40.4510, -86.9880\n40.4492, -86.9870"></textarea>
            <button id="setPolyBtn" type="button">Set polygon</button>
          </div>

          <div class="row">
            <label>Polygon vertices (read-only)</label>
            <textarea id="polyCoords" readonly placeholder="Draw a polygon to see vertices..."></textarea>
          </div>

          <div class="row small" id="polyStatus">Ready</div>
        </div>
      `;

      // prevent map drag/zoom when clicking inside control
      L.DomEvent.disableClickPropagation(container);
      L.DomEvent.disableScrollPropagation(container);

      return container;
    }
  });
  map.addControl(new PolygonControl());

  // ===== state =====
  let sampleLayer = null;
  let currentPolygon = null;
  let currentAreaM2 = null;
  let lastReco = null;
  let lastSamples = null;

  // Tier thresholds interpreted as coverage (0..1) of covariate heterogeneity.
  const COVERAGE_THRESH = { weak: 0.60, medium: 0.75, good: 0.88, perfect: 0.95 };

  const polyStatusEl = () => document.getElementById('polyStatus');
  const setPolyStatus = (m) => { const el = polyStatusEl(); if (el) el.textContent = m; };

  function fmtNum(x) {
    if (!isFinite(x)) return '—';
    const ax = Math.abs(x);
    if (ax >= 1000) return x.toFixed(0);
    if (ax >= 100) return x.toFixed(1);
    if (ax >= 10) return x.toFixed(2);
    return x.toFixed(3);
  }

  function areaSummaryHtml() {
    if (!currentAreaM2 || !isFinite(currentAreaM2) || currentAreaM2 <= 0) return `Area: —<br>`;
    const acres = currentAreaM2 / 4046.8564224;
    const sqmi = currentAreaM2 / 2589988.110336;
    const ha = currentAreaM2 / 10000;
    const sqkm = currentAreaM2 / 1e6;
    return `Area: <b>${fmtNum(acres)} acres</b> (${fmtNum(ha)} ha) • ${fmtNum(sqmi)} mi² (${fmtNum(sqkm)} km²)<br>`;
  }

  async function postJSON(url, payload) {
    const r = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!r.ok) {
      const txt = await r.text();
      throw new Error(`HTTP ${r.status}: ${txt}`);
    }
    return await r.json();
  }

  function setDisabled(id, disabled) {
    const el = document.getElementById(id);
    if (el) el.disabled = !!disabled;
  }

  function setActionButtonsEnabled(hasPolygon) {
    setDisabled('analyzeBtn', !hasPolygon);
    setDisabled('sampleBtn', !hasPolygon);
    const hint = document.getElementById('analyzeHint');
    if (hint) {
      hint.textContent = hasPolygon
        ? "Polygon ready. Click 'Analyze polygon' to get suggested N tiers."
        : "Draw / set a polygon to enable analysis.";
    }
  }

  function updateModeUI() {
    const mode = document.getElementById('mode').value;
    setDisabled('costPerSample', false);

    if (mode === 'manual') {
      setDisabled('manualN', false);
      setDisabled('budget', true);
      setDisabled('tier', true);
    } else if (mode === 'budget') {
      setDisabled('manualN', true);
      setDisabled('budget', false);
      setDisabled('tier', true);
    } else {
      setDisabled('manualN', true);
      setDisabled('budget', true);
      setDisabled('tier', false);
    }
  }

  function updatePolyModeUI() {
    const pm = document.getElementById('polyMode').value;
    document.getElementById('coordsBox').style.display = (pm === 'coords') ? 'block' : 'none';
    document.getElementById('fileBox').style.display = (pm === 'file') ? 'block' : 'none';
  }

  function setPolyFileStatus(msg) {
    const el = document.getElementById('polyFileStatus');
    if (el) el.textContent = msg;
  }

  function polygonToCoordsText(layer) {
    try {
      const latlngs = layer.getLatLngs()[0] || [];
      return latlngs.map((p, i) => `${i+1}) ${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`).join('\n');
    } catch {
      return '';
    }
  }

  function clearPolygonState() {
    currentPolygon = null;
    currentAreaM2 = null;
    lastReco = null;
    lastSamples = null;

    if (sampleLayer) {
      map.removeLayer(sampleLayer);
      sampleLayer = null;
    }

    const polyCoords = document.getElementById('polyCoords');
    if (polyCoords) polyCoords.value = '';

    document.getElementById('recoBox').innerHTML = `Area: —<br>Candidates: —<br>Recommendations: —<br>`;
    document.getElementById('samplesBox').value = '';

    setActionButtonsEnabled(false);
    setPolyStatus("No polygon. Draw one, paste coordinates, or upload a file.");
  }

  function setPolygonFromLayer(layer) {
    const feat = layer.toGeoJSON();
    currentPolygon = feat.geometry;

    // area
    try {
      currentAreaM2 = (typeof turf !== 'undefined') ? turf.area(feat) : null;
    } catch {
      currentAreaM2 = null;
    }

    const polyCoords = document.getElementById('polyCoords');
    if (polyCoords) polyCoords.value = polygonToCoordsText(layer);

    lastReco = null;
    lastSamples = null;

    document.getElementById('recoBox').innerHTML = `${areaSummaryHtml()}Candidates: —<br>Recommendations: —<br>`;
    document.getElementById('samplesBox').value = '';

    setActionButtonsEnabled(true);
    setPolyStatus("Polygon set. Click 'Analyze polygon'.");
  }

  function normalizeToFeatureCollection(gj) {
    if (!gj) return null;
    if (gj.type === 'FeatureCollection') return gj;
    if (gj.type === 'Feature') return { type: 'FeatureCollection', features: [gj] };
    if (gj.type && gj.coordinates) {
      return { type: 'FeatureCollection', features: [{ type: 'Feature', properties: {}, geometry: gj }] };
    }
    return null;
  }

  function pickBestPolygonFeature(fc) {
    const feats = (fc && fc.features ? fc.features : []).filter(f => f && f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
    if (!feats.length) throw new Error('No Polygon/MultiPolygon found in file.');

    // choose largest by area
    let best = feats[0];
    let bestA = -Infinity;
    for (const f of feats) {
      try {
        const a = (typeof turf !== 'undefined') ? turf.area(f) : 0;
        if (a > bestA) { bestA = a; best = f; }
      } catch {}
    }
    return best;
  }

  function setPolygonFromGeoJSON(gj) {
    const fc = normalizeToFeatureCollection(gj);
    if (!fc) throw new Error('Could not parse file as GeoJSON.');

    const polyFeat = pickBestPolygonFeature(fc);

    // Create a Leaflet layer from the feature.
    const geo = L.geoJSON(polyFeat, { style: { color: '#3388ff' } });
    let chosenLayer = null;
    geo.eachLayer(l => { if (!chosenLayer) chosenLayer = l; });
    if (!chosenLayer) throw new Error('Could not create a polygon layer from the file.');

    drawnItems.clearLayers();
    drawnItems.addLayer(chosenLayer);
    map.fitBounds(chosenLayer.getBounds(), { padding: [20,20] });
    setPolygonFromLayer(chosenLayer);
  }

  function parseCoordsText(text) {
    const lines = (text || '').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const pts = [];
    for (const line of lines) {
      const parts = line.split(/[,\s]+/).filter(Boolean);
      if (parts.length < 2) continue;
      const a = parseFloat(parts[0]);
      const b = parseFloat(parts[1]);
      if (!isFinite(a) || !isFinite(b)) continue;

      let lat, lon;
      if (Math.abs(a) > 90) { lon = a; lat = b; } else { lat = a; lon = b; }
      pts.push([lat, lon]);
    }
    if (pts.length < 3) throw new Error('Need at least 3 points.');

    // Close ring
    const first = pts[0], last = pts[pts.length - 1];
    const closeEnough = Math.abs(first[0]-last[0]) < 1e-10 && Math.abs(first[1]-last[1]) < 1e-10;
    if (!closeEnough) pts.push(first);
    return pts;
  }

  async function handlePolygonFile(file) {
    if (!file) return;
    const name = (file.name || '').toLowerCase();
    setPolyFileStatus(`Loading: ${file.name} ...`);
    setPolyStatus('Loading AOI file...');

    try {
      // GeoJSON / JSON
      if (name.endsWith('.geojson') || name.endsWith('.json')) {
        const txt = await file.text();
        const gj = JSON.parse(txt);
        setPolygonFromGeoJSON(gj);
        setPolyFileStatus(`Loaded: ${file.name}`);
        return;
      }

      // KML
      if (name.endsWith('.kml')) {
        const txt = await file.text();
        const dom = new DOMParser().parseFromString(txt, 'text/xml');
        const gj = toGeoJSON.kml(dom);
        setPolygonFromGeoJSON(gj);
        setPolyFileStatus(`Loaded: ${file.name}`);
        return;
      }

      // KMZ
      if (name.endsWith('.kmz')) {
        const buf = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(buf);
        const kmlName = Object.keys(zip.files).find(k => k.toLowerCase().endsWith('.kml'));
        if (!kmlName) throw new Error('KMZ does not contain a .kml file.');
        const kmlTxt = await zip.files[kmlName].async('string');
        const dom = new DOMParser().parseFromString(kmlTxt, 'text/xml');
        const gj = toGeoJSON.kml(dom);
        setPolygonFromGeoJSON(gj);
        setPolyFileStatus(`Loaded: ${file.name}`);
        return;
      }

      // Zipped shapefile
      if (name.endsWith('.zip')) {
        const buf = await file.arrayBuffer();
        const gj = await shp(buf); // shpjs
        setPolygonFromGeoJSON(gj);
        setPolyFileStatus(`Loaded: ${file.name}`);
        return;
      }

      throw new Error('Unsupported file. Use .geojson/.json, .kml, .kmz, or .zip shapefile.');
    } catch (e) {
      console.error(e);
      setPolyFileStatus(`Failed: ${e.message}`);
      setPolyStatus('AOI load failed');
      alert('Could not load polygon file:\n' + e.message);
    }
  }

  function updateRecoBox(reco) {
    const box = document.getElementById('recoBox');

    if (!reco || reco.candidates_count === 0) {
      box.innerHTML =
        `${areaSummaryHtml()}` +
        `Candidates: <b>0</b><br>` +
        `Recommendations: (no candidates inside polygon)<br>`;
      return;
    }

    const cost = parseFloat(document.getElementById('costPerSample').value || '25');
    const w = reco.tiers.weak, m = reco.tiers.medium, g = reco.tiers.good, p = reco.tiers.perfect;

    box.innerHTML =
      `${areaSummaryHtml()}` +
      `Candidates: <b>${reco.candidates_count}</b><br>` +
      `Tier meaning (coverage of covariate heterogeneity):<br>` +
      `Weak ≥ ${(COVERAGE_THRESH.weak*100).toFixed(0)}%, Medium ≥ ${(COVERAGE_THRESH.medium*100).toFixed(0)}%, ` +
      `Good ≥ ${(COVERAGE_THRESH.good*100).toFixed(0)}%, Perfect ≥ ${(COVERAGE_THRESH.perfect*100).toFixed(0)}%<br><br>` +
      `Suggested N (est. cost):<br>` +
      `Weak: <b>${w}</b> ($${(w*cost).toFixed(0)})<br>` +
      `Medium: <b>${m}</b> ($${(m*cost).toFixed(0)})<br>` +
      `Good: <b>${g}</b> ($${(g*cost).toFixed(0)})<br>` +
      `Perfect: <b>${p}</b> ($${(p*cost).toFixed(0)})<br>`;
  }

  function computeNFromMode() {
    const mode = document.getElementById('mode').value;
    const cost = parseFloat(document.getElementById('costPerSample').value || '25');
    const manualN = parseInt(document.getElementById('manualN').value || '1', 10);
    const budget = parseFloat(document.getElementById('budget').value || '0');
    const tier = document.getElementById('tier').value;

    if (mode === 'manual') return Math.max(1, manualN);
    if (mode === 'budget') return Math.max(1, Math.floor(budget / Math.max(1, cost)));
    if (lastReco && lastReco.tiers && lastReco.tiers[tier] != null) {
      return Math.max(1, parseInt(lastReco.tiers[tier], 10));
    }
    return Math.max(1, manualN);
  }

  async function analyzePolygon() {
    if (!currentPolygon) return alert('Draw a polygon, paste coordinates, or upload a file first.');

    const cost = parseFloat(document.getElementById('costPerSample').value || '25');
    const metric = (document.getElementById('metric') && document.getElementById('metric').value) ? document.getElementById('metric').value : 'bd';

    const btn = document.getElementById('analyzeBtn');
    const prevTxt = btn.textContent;

    setPolyStatus('Analyzing polygon...');
    btn.textContent = 'Analyzing...';
    setDisabled('analyzeBtn', true);
    setDisabled('sampleBtn', true);

    document.getElementById('recoBox').innerHTML = `${areaSummaryHtml()}Candidates: —<br>Recommendations: <i>Computing...</i><br>`;

    try {
      const reco = await postJSON('/api/recommend-n', { polygon: currentPolygon, cost_per_sample: cost, metric });
      lastReco = reco;
      updateRecoBox(reco);

      if (reco && reco.tiers && reco.tiers.good) {
        document.getElementById('manualN').value = reco.tiers.good;
        document.getElementById('tier').value = 'good';
      }

      setPolyStatus('Recommendations updated.');
    } catch (err) {
      console.error(err);
      setPolyStatus('Analyze failed');
      alert('Analyze failed:\n' + err.message);
    } finally {
      btn.textContent = prevTxt;
      setActionButtonsEnabled(!!currentPolygon);
    }
  }

  function featuresToTextAndCSV(fc) {
    const feats = fc && fc.features ? fc.features : [];
    const lines = [];
    const csv = [];
    csv.push(['idx','id','lat','lon','x_utm','y_utm'].join(','));
    feats.forEach((f, i) => {
      const p = f.properties || {};
      const id = (p.id == null ? '' : p.id);
      const lat = (p.lat == null ? '' : p.lat);
      const lon = (p.lon == null ? '' : p.lon);
      const x = (p.x == null ? '' : p.x);
      const y = (p.y == null ? '' : p.y);
      lines.push(`${i+1}) ${lat}, ${lon}  (id=${id})`);
      csv.push([i+1, id, lat, lon, x, y].join(','));
    });
    return { text: lines.join('\n'), csv: csv.join('\n') };
  }

  async function generateSamples() {
    if (!currentPolygon) return alert('Draw a polygon, paste coordinates, or upload a file first.');

    const mode = document.getElementById('mode').value;
    if (mode === 'tier' && !lastReco) {
      await analyzePolygon();
      if (!lastReco || lastReco.candidates_count === 0) return;
    }

    const n = computeNFromMode();
    const btn = document.getElementById('sampleBtn');
    const prevTxt = btn.textContent;

    setPolyStatus(`Selecting samples (N=${n})...`);
    btn.textContent = 'Loading...';
    setDisabled('sampleBtn', true);
    setDisabled('analyzeBtn', true);

    try {
      const data = await postJSON('/api/suggest-samples', { polygon: currentPolygon, n_samples: n });
      lastSamples = data;

      if (sampleLayer) map.removeLayer(sampleLayer);
      sampleLayer = L.geoJSON(data, {
        pointToLayer: (feature, latlng) =>
          L.circleMarker(latlng, { radius: 6, weight: 3 })
            .bindPopup(
              `ID: ${feature.properties && feature.properties.id != null ? feature.properties.id : 'NA'}<br>` +
              `Lat/Lon: ${feature.properties && typeof feature.properties.lat === 'number' ? feature.properties.lat.toFixed(6) : ''}, ` +
              `${feature.properties && typeof feature.properties.lon === 'number' ? feature.properties.lon.toFixed(6) : ''}`
            )
      }).addTo(map);

      const pack = featuresToTextAndCSV(data);
      document.getElementById('samplesBox').value = pack.text;

      setPolyStatus(`Done: ${(data.features || []).length} points`);
    } catch (err) {
      console.error(err);
      setPolyStatus('Fetch failed');
      alert('Error fetching samples:\n' + err.message);
    } finally {
      btn.textContent = prevTxt;
      setActionButtonsEnabled(!!currentPolygon);
    }
  }

  // ===== downloads =====
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function buildAOIFeature() {
    if (!currentPolygon) return null;
    return { type: 'Feature', properties: { role: 'aoi' }, geometry: currentPolygon };
  }

  function buildDownloadFeatureCollection(includeAOI) {
    if (!lastSamples) return null;
    const feats = [];
    if (includeAOI) {
      const aoi = buildAOIFeature();
      if (aoi) feats.push(aoi);
    }
    // include sample points
    for (const f of (lastSamples.features || [])) feats.push(f);
    return { type: 'FeatureCollection', features: feats };
  }

  function pointsOnlyFC() {
    if (!lastSamples) return null;
    // shapefile export prefers homogeneous geometry
    return { type: 'FeatureCollection', features: (lastSamples.features || []) };
  }

  async function downloadSamples() {
    if (!lastSamples) return alert('No samples yet. Generate samples first.');

    const fmt = document.getElementById('downloadFormat').value;

    try {
      if (fmt === 'csv') {
        const pack = featuresToTextAndCSV(lastSamples);
        downloadBlob(new Blob([pack.csv], { type: 'text/csv;charset=utf-8;' }), 'soil_samples.csv');
        return;
      }

      if (fmt === 'geojson') {
        const fc = buildDownloadFeatureCollection(true);
        const txt = JSON.stringify(fc, null, 2);
        downloadBlob(new Blob([txt], { type: 'application/geo+json' }), 'soil_samples.geojson');
        return;
      }

      if (fmt === 'kml' || fmt === 'kmz') {
        const fc = buildDownloadFeatureCollection(true);
        const kml = tokml(fc, { name: 'id', description: 'role' });
        if (fmt === 'kml') {
          downloadBlob(new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' }), 'soil_samples.kml');
        } else {
          const zip = new JSZip();
          zip.file('doc.kml', kml);
          const kmzBlob = await zip.generateAsync({ type: 'blob' });
          downloadBlob(kmzBlob, 'soil_samples.kmz');
        }
        return;
      }

      if (fmt === 'shp') {
        const fcPts = pointsOnlyFC();
        // shpwrite.zip returns a Blob
        const blob = shpwrite.zip(fcPts, {
          folder: 'soil_samples',
          types: { point: 'soil_samples_points' }
        });
        downloadBlob(blob, 'soil_samples_shapefile.zip');
        return;
      }

      alert('Unsupported download format.');
    } catch (e) {
      console.error(e);
      alert('Download failed:\n' + e.message);
    }
  }

  // ===== Right panel hide/show =====
  const rightPanel = document.getElementById('rightPanel');
  const showRightFloat = document.getElementById('showRightFloat');
  document.getElementById('hideRightBtn').addEventListener('click', () => {
    rightPanel.classList.add('hidden');
    showRightFloat.style.display = 'block';
  });
  document.getElementById('showRightBtn').addEventListener('click', () => {
    rightPanel.classList.remove('hidden');
    showRightFloat.style.display = 'none';
  });

  // ===== Polygon control hide/show (collapse) =====
  function wirePolygonToggle() {
    const btn = document.getElementById('polyToggleBtn');
    const body = document.getElementById('polyBody');
    if (!btn || !body) return;
    btn.addEventListener('click', () => {
      const isHidden = body.classList.toggle('hidden');
      btn.textContent = isHidden ? 'Show' : 'Hide';
    });
  }

  // Wire UI after control DOM exists
  function wirePolygonUI() {
    wirePolygonToggle();
    document.getElementById('polyMode').addEventListener('change', updatePolyModeUI);
    updatePolyModeUI();

    document.getElementById('setPolyBtn').addEventListener('click', () => {
      try {
        const pts = parseCoordsText(document.getElementById('coordsInput').value || '');
        const poly = L.polygon(pts, { color: '#3388ff' });
        drawnItems.clearLayers();
        drawnItems.addLayer(poly);
        map.fitBounds(poly.getBounds(), { padding: [20,20] });
        setPolygonFromLayer(poly);
      } catch (e) {
        alert('Could not parse polygon coordinates:\n' + e.message);
      }
    });

    const fileInput = document.getElementById('polyFileInput');
    if (fileInput) {
      fileInput.addEventListener('change', async (ev) => {
        const f = ev.target.files && ev.target.files[0] ? ev.target.files[0] : null;
        await handlePolygonFile(f);
      });
    }
  }
  wirePolygonUI();

  // initial state
  clearPolygonState();

  // Mode UI wiring
  document.getElementById('mode').addEventListener('change', updateModeUI);
  updateModeUI();

  // If the user changes cost/sample after analyzing, refresh displayed costs.
  document.getElementById('costPerSample').addEventListener('input', () => {
    if (lastReco) updateRecoBox(lastReco);
  });

  document.getElementById('analyzeBtn').addEventListener('click', analyzePolygon);
  document.getElementById('sampleBtn').addEventListener('click', generateSamples);

  document.getElementById('copyBtn').addEventListener('click', async () => {
    const txt = document.getElementById('samplesBox').value || '';
    if (!txt.trim()) return alert('No sample coordinates yet.');
    try {
      await navigator.clipboard.writeText(txt);
      setPolyStatus('Copied coordinates.');
    } catch {
      alert('Copy failed. You can still select + copy manually.');
    }
  });

  document.getElementById('downloadBtn').addEventListener('click', downloadSamples);

  // Draw events
  map.on(L.Draw.Event.CREATED, function (event) {
    drawnItems.clearLayers();
    drawnItems.addLayer(event.layer);
    setPolygonFromLayer(event.layer);
  });

  map.on('draw:edited', function (e) {
    e.layers.eachLayer(function (layer) {
      setPolygonFromLayer(layer);
    });
  });

  map.on('draw:deleted', function () {
    clearPolygonState();
  });
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Soil Sampling Prototype</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #map { height: 100%; }

    /* RIGHT panel */
    .panel {
      position: absolute;
      z-index: 9999;
      background: white;
      padding: 12px;
      border-radius: 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.22);
      font: 13px/1.4 Arial, sans-serif;
      max-height: calc(100% - 20px);
      overflow: auto;
      width: 360px;
      top: 10px;
      right: 10px;
    }

    .row { margin: 8px 0; }
    label { display:block; font-weight:600; margin-bottom:4px; }
    input, select, button, textarea { width: 100%; padding: 6px; box-sizing: border-box; }
    textarea {
      min-height: 70px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
    }
    button { cursor: pointer; }
    .small { font-size: 12px; color: #444; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .hidden { display: none; }

    /* Smaller circular vertex handles */
    .leaflet-div-icon.leaflet-editing-icon {
      width: 10px !important;
      height: 10px !important;
      margin-left: -5px !important;
      margin-top: -5px !important;
      border-radius: 50% !important;
      background: #ffffff !important;
      border: 2px solid #3388ff !important;
      box-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }

    /* Floating show button (right panel) */
    .floating-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10000;
      background: white;
      border-radius: 10px;
      padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.22);
      display: none;
    }

    /* ===== Leaflet "merged" polygon control ===== */
    .leaflet-control.polygon-control {
      width: 260px;
      padding: 10px;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.20);
      border: 1px solid rgba(0,0,0,0.10);

      /* actually transparent */
      background: rgba(255,255,255,0.75);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);

      font: 13px/1.3 Arial, sans-serif;
    }
    .poly-head {
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:8px;
      font-weight:700;
    }
    .poly-head button {
      width:auto;
      padding: 4px 8px;
      font-weight:600;
    }
    .poly-body.hidden { display:none; }
    .poly-mini {
      font-size:12px;
      color:#444;
      margin-bottom:6px;
    }
    .poly-body textarea { min-height: 64px; }
  </style>
</head>
<body>
<div id="map"></div>

<!-- RIGHT: sampling + outputs -->
<div class="panel" id="rightPanel">
  <div class="row" style="display:flex; justify-content:space-between; align-items:center;">
    <strong>Sampling Planner</strong>
    <button id="hideRightBtn" style="width:auto; padding:6px 10px;">Hide</button>
  </div>

  <div class="row">
    <label>Mode</label>
    <select id="mode">
      <option value="manual">Manual (choose N)</option>
      <option value="budget">Budget ($ → N)</option>
      <option value="tier">Recommended Tier</option>
    </select>
  </div>

  <div class="row grid">
    <div>
      <label>Manual N</label>
      <input id="manualN" type="number" value="30" min="1" step="1">
    </div>
    <div>
      <label>Cost / sample ($)</label>
      <input id="costPerSample" type="number" value="25" min="1" step="1">
    </div>
  </div>

  <div class="row">
    <label>Budget ($)</label>
    <input id="budget" type="number" value="750" min="0" step="25">
  </div>

  <div class="row">
    <label>Tier</label>
    <select id="tier">
      <option value="weak">Weak</option>
      <option value="medium">Medium</option>
      <option value="good" selected>Good</option>
      <option value="perfect">Perfect</option>
    </select>
  </div>

  <div class="row grid">
    <button id="analyzeBtn">Analyze polygon</button>
    <button id="sampleBtn">Generate samples</button>
  </div>

  <div class="row small" id="recoBox">
    Candidates: —<br>
    Recommendations: —<br>
  </div>

  <div class="row">
    <label>Selected sample coordinates</label>
    <textarea id="samplesBox" readonly placeholder="Generate samples to see coordinates..."></textarea>
    <div class="grid">
      <button id="copyBtn">Copy</button>
      <button id="csvBtn">Download CSV</button>
    </div>
  </div>
</div>

<div class="floating-btn" id="showRightFloat">
  <button id="showRightBtn" style="width:auto; padding:6px 10px;">Show planner</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
  const map = L.map('map').setView([40.45, -86.99], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

  fetch('/api/extent')
    .then(r => r.ok ? r.json() : null)
    .then(d => { if (d?.bounds) map.fitBounds(d.bounds, { padding: [20,20] }); })
    .catch(() => {});

  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  const drawControl = new L.Control.Draw({
    position: 'topleft',
    edit: { featureGroup: drawnItems },
    draw: { polygon: true, polyline: false, rectangle: false, circle: false, marker: false, circlemarker: false }
  });
  map.addControl(drawControl);

  // ===== merged polygon control (sits under draw toolbar automatically) =====
  const PolygonControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
      const container = L.DomUtil.create('div', 'leaflet-control polygon-control');
      container.innerHTML = `
        <div class="poly-head">
          <div>Polygon</div>
          <button id="polyToggleBtn" type="button">Hide</button>
        </div>

        <div class="poly-body" id="polyBody">
          <div class="poly-mini">
            Use the polygon button above, or paste coordinates.
          </div>

          <div class="row">
            <label>Polygon input</label>
            <select id="polyMode">
              <option value="draw" selected>Draw on map</option>
              <option value="coords">Paste coordinates</option>
            </select>
          </div>

          <div class="row" id="coordsBox" style="display:none;">
            <label>Paste polygon coordinates</label>
            <div class="small">One point per line. lat,lon or lon,lat.</div>
            <textarea id="coordsInput" placeholder="40.4501, -86.9902&#10;40.4510, -86.9880&#10;40.4492, -86.9870"></textarea>
            <button id="setPolyBtn" type="button">Set polygon</button>
          </div>

          <div class="row">
            <label>Polygon vertices (read-only)</label>
            <textarea id="polyCoords" readonly placeholder="Draw a polygon to see vertices..."></textarea>
          </div>

          <div class="row small" id="polyStatus">Ready</div>
        </div>
      `;

      // prevent map drag/zoom when clicking inside control
      L.DomEvent.disableClickPropagation(container);
      L.DomEvent.disableScrollPropagation(container);

      return container;
    }
  });
  map.addControl(new PolygonControl());

  // ===== state =====
  let sampleLayer = null;
  let currentPolygon = null;
  let lastReco = null;
  let lastSamples = null;

  const GAIN_THRESH = { weak: 0.60, medium: 0.75, good: 0.88, perfect: 0.95 };

  const polyStatusEl = () => document.getElementById('polyStatus');
  const setPolyStatus = (m) => { const el = polyStatusEl(); if (el) el.textContent = m; };

  async function postJSON(url, payload) {
    const r = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!r.ok) {
      const txt = await r.text();
      throw new Error(`HTTP ${r.status}: ${txt}`);
    }
    return await r.json();
  }

  function setDisabled(id, disabled) {
    const el = document.getElementById(id);
    if (el) el.disabled = !!disabled;
  }

  function updateModeUI() {
    const mode = document.getElementById('mode').value;
    setDisabled('costPerSample', false);

    if (mode === 'manual') {
      setDisabled('manualN', false);
      setDisabled('budget', true);
      setDisabled('tier', true);
    } else if (mode === 'budget') {
      setDisabled('manualN', true);
      setDisabled('budget', false);
      setDisabled('tier', true);
    } else {
      setDisabled('manualN', true);
      setDisabled('budget', true);
      setDisabled('tier', false);
    }
  }

  function updatePolyModeUI() {
    const pm = document.getElementById('polyMode').value;
    document.getElementById('coordsBox').style.display = (pm === 'coords') ? 'block' : 'none';
  }

  function polygonToCoordsText(layer) {
    try {
      const latlngs = layer.getLatLngs()[0] || [];
      return latlngs.map((p, i) => `${i+1}) ${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`).join('\n');
    } catch { return ''; }
  }

  function setPolygonFromLayer(layer) {
    currentPolygon = layer.toGeoJSON().geometry;
    const polyCoords = document.getElementById('polyCoords');
    if (polyCoords) polyCoords.value = polygonToCoordsText(layer);

    lastReco = null;
    lastSamples = null;
    document.getElementById('recoBox').innerHTML = `Candidates: —<br>Recommendations: —<br>`;
    document.getElementById('samplesBox').value = '';
    setPolyStatus("Polygon set. Click 'Analyze polygon'.");
  }

  function parseCoordsText(text) {
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const pts = [];
    for (const line of lines) {
      const parts = line.split(/[,\s]+/).filter(Boolean);
      if (parts.length < 2) continue;
      const a = parseFloat(parts[0]);
      const b = parseFloat(parts[1]);
      if (!isFinite(a) || !isFinite(b)) continue;

      let lat, lon;
      if (Math.abs(a) > 90) { lon = a; lat = b; } else { lat = a; lon = b; }
      pts.push([lat, lon]);
    }
    if (pts.length < 3) throw new Error("Need at least 3 points.");
    const first = pts[0], last = pts[pts.length - 1];
    const closeEnough = Math.abs(first[0]-last[0]) < 1e-10 && Math.abs(first[1]-last[1]) < 1e-10;
    if (!closeEnough) pts.push(first);
    return pts;
  }

  function updateRecoBox(reco) {
    const box = document.getElementById('recoBox');
    if (!reco || reco.candidates_count === 0) {
      box.innerHTML = `Candidates: <b>0</b><br>Recommendations: (no candidates inside polygon)<br>`;
      return;
    }
    const cost = parseFloat(document.getElementById('costPerSample').value || "25");
    const w = reco.tiers.weak, m = reco.tiers.medium, g = reco.tiers.good, p = reco.tiers.perfect;

    box.innerHTML =
      `Candidates: <b>${reco.candidates_count}</b><br>` +
      `Tier meaning (coverage of covariate heterogeneity):<br>` +
      `Weak ≥ ${(GAIN_THRESH.weak*100).toFixed(0)}%, Medium ≥ ${(GAIN_THRESH.medium*100).toFixed(0)}%, ` +
      `Good ≥ ${(GAIN_THRESH.good*100).toFixed(0)}%, Perfect ≥ ${(GAIN_THRESH.perfect*100).toFixed(0)}%<br><br>` +
      `Suggested N (est. cost):<br>` +
      `Weak: <b>${w}</b> ($${(w*cost).toFixed(0)})<br>` +
      `Medium: <b>${m}</b> ($${(m*cost).toFixed(0)})<br>` +
      `Good: <b>${g}</b> ($${(g*cost).toFixed(0)})<br>` +
      `Perfect: <b>${p}</b> ($${(p*cost).toFixed(0)})<br>`;
  }

  function computeNFromMode() {
    const mode = document.getElementById('mode').value;
    const cost = parseFloat(document.getElementById('costPerSample').value || "25");
    const manualN = parseInt(document.getElementById('manualN').value || "1", 10);
    const budget = parseFloat(document.getElementById('budget').value || "0");
    const tier = document.getElementById('tier').value;

    if (mode === 'manual') return Math.max(1, manualN);
    if (mode === 'budget') return Math.max(1, Math.floor(budget / Math.max(1, cost)));
    if (lastReco && lastReco.tiers && lastReco.tiers[tier] != null) {
      return Math.max(1, parseInt(lastReco.tiers[tier], 10));
    }
    return Math.max(1, manualN);
  }

  async function analyzePolygon() {
    if (!currentPolygon) return alert("Draw a polygon or paste coordinates first.");
    const cost = parseFloat(document.getElementById('costPerSample').value || "25");
    setPolyStatus("Analyzing polygon...");
    try {
      const reco = await postJSON('/api/recommend-n', { polygon: currentPolygon, cost_per_sample: cost });
      lastReco = reco;
      updateRecoBox(reco);
      if (reco?.tiers?.good) {
        document.getElementById('manualN').value = reco.tiers.good;
        document.getElementById('tier').value = 'good';
      }
      setPolyStatus("Recommendations updated.");
    } catch (err) {
      console.error(err);
      setPolyStatus("Analyze failed");
      alert("Analyze failed:\n" + err.message);
    }
  }

  function featuresToTextAndCSV(fc) {
    const feats = fc.features || [];
    const lines = [];
    const csv = [];
    csv.push(["idx","id","lat","lon","x_utm","y_utm"].join(","));
    feats.forEach((f, i) => {
      const p = f.properties || {};
      const id = (p.id == null ? "" : p.id);
      const lat = (p.lat == null ? "" : p.lat);
      const lon = (p.lon == null ? "" : p.lon);
      const x = (p.x == null ? "" : p.x);
      const y = (p.y == null ? "" : p.y);
      lines.push(`${i+1}) ${lat}, ${lon}  (id=${id})`);
      csv.push([i+1, id, lat, lon, x, y].join(","));
    });
    return { text: lines.join("\n"), csv: csv.join("\n") };
  }

  async function generateSamples() {
    if (!currentPolygon) return alert("Draw a polygon or paste coordinates first.");

    const mode = document.getElementById('mode').value;
    if (mode === 'tier' && !lastReco) {
      await analyzePolygon();
      if (!lastReco || lastReco.candidates_count === 0) return;
    }

    const n = computeNFromMode();
    setPolyStatus(`Selecting samples (N=${n})...`);
    try {
      const data = await postJSON('/api/suggest-samples', { polygon: currentPolygon, n_samples: n });
      lastSamples = data;

      if (sampleLayer) map.removeLayer(sampleLayer);
      sampleLayer = L.geoJSON(data, {
        pointToLayer: (feature, latlng) =>
          L.circleMarker(latlng, { radius: 6, weight: 3 })
            .bindPopup(
              `ID: ${feature.properties?.id ?? "NA"}<br>` +
              `Lat/Lon: ${feature.properties?.lat?.toFixed?.(6) ?? ""}, ${feature.properties?.lon?.toFixed?.(6) ?? ""}`
            )
      }).addTo(map);

      const pack = featuresToTextAndCSV(data);
      document.getElementById('samplesBox').value = pack.text;

      setPolyStatus(`Done: ${(data.features || []).length} points`);
    } catch (err) {
      console.error(err);
      setPolyStatus("Fetch failed");
      alert("Error fetching samples:\n" + err.message);
    }
  }

  // Right panel hide/show
  const rightPanel = document.getElementById('rightPanel');
  const showRightFloat = document.getElementById('showRightFloat');
  document.getElementById('hideRightBtn').addEventListener('click', () => {
    rightPanel.classList.add('hidden');
    showRightFloat.style.display = 'block';
  });
  document.getElementById('showRightBtn').addEventListener('click', () => {
    rightPanel.classList.remove('hidden');
    showRightFloat.style.display = 'none';
  });

  // Polygon control hide/show (collapse)
  function wirePolygonToggle() {
    const btn = document.getElementById('polyToggleBtn');
    const body = document.getElementById('polyBody');
    if (!btn || !body) return;
    btn.addEventListener('click', () => {
      const isHidden = body.classList.toggle('hidden');
      btn.textContent = isHidden ? 'Show' : 'Hide';
    });
  }

  // Wire UI after control DOM exists
  function wirePolygonUI() {
    wirePolygonToggle();
    document.getElementById('polyMode').addEventListener('change', updatePolyModeUI);
    updatePolyModeUI();

    document.getElementById('setPolyBtn').addEventListener('click', () => {
      try {
        const pts = parseCoordsText(document.getElementById('coordsInput').value || '');
        const poly = L.polygon(pts, { color: '#3388ff' });
        drawnItems.clearLayers();
        drawnItems.addLayer(poly);
        map.fitBounds(poly.getBounds(), { padding: [20,20] });
        setPolygonFromLayer(poly);
      } catch (e) {
        alert("Could not parse polygon coordinates:\n" + e.message);
      }
    });
  }
  wirePolygonUI();

  // Mode UI wiring
  document.getElementById('mode').addEventListener('change', updateModeUI);
  updateModeUI();

  document.getElementById('analyzeBtn').addEventListener('click', analyzePolygon);
  document.getElementById('sampleBtn').addEventListener('click', generateSamples);

  document.getElementById('copyBtn').addEventListener('click', async () => {
    const txt = document.getElementById('samplesBox').value || '';
    if (!txt.trim()) return alert("No sample coordinates yet.");
    try {
      await navigator.clipboard.writeText(txt);
      setPolyStatus("Copied coordinates.");
    } catch {
      alert("Copy failed. You can still select + copy manually.");
    }
  });

  document.getElementById('csvBtn').addEventListener('click', () => {
    if (!lastSamples) return alert("No samples yet.");
    const pack = featuresToTextAndCSV(lastSamples);
    const blob = new Blob([pack.csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "soil_samples.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  // Draw events
  map.on(L.Draw.Event.CREATED, function (event) {
    drawnItems.clearLayers();
    drawnItems.addLayer(event.layer);
    setPolygonFromLayer(event.layer);
  });

  map.on('draw:edited', function (e) {
    e.layers.eachLayer(function (layer) {
      setPolygonFromLayer(layer);
    });
  });
</script>
</body>
</html>
